from ..selection_algorithm import SelectionAlgorithm
from ..index import Index
import logging

# cost_estimation: 'whatif' or 'acutal_runtimes'
# Index combination budget in MB
DEFAULT_PARAMETERS = {'cost_estimation': 'whatif', 'budget': 10, 'min_cost_improvement': 1.01}


class EPICAlgorithm(SelectionAlgorithm):
    def __init__(self, database_connector, parameters=None):
        if parameters == None:
            parameters = {}
        SelectionAlgorithm.__init__(self, database_connector, parameters,
                                    DEFAULT_PARAMETERS)
        # MB to Bytes
        self.budget = self.parameters['budget'] * 1000000
        self.workload = None
        self.min_cost_improvement = self.parameters['min_cost_improvement']

    def _calculate_best_indexes(self, workload):
        logging.info('Calculating best indexes EPIC')
        self.workload = workload
        single_attribute_index_candidates = self.workload.potential_indexes()

        # Current index combination
        index_combination = []
        index_combination_size = 0
        # Best index combination during evaluation step
        best = {'combination': [], 'benefit_to_size_ratio': 0, 'cost': None}

        current_cost = self._retrieve_cost(index_combination)
        # Breaking when no cost improvement
        while True:
            single_attribute_index_candidates = self._remove_candidates_too_large_for_budget(index_combination_size, single_attribute_index_candidates)
            for candidate in single_attribute_index_candidates:
                # Only single column index generation
                if candidate not in index_combination:
                    self._evaluate_combination(index_combination + [candidate],
                                               best, current_cost)

                # Multi column indexes are generated by attaching columns to existing indexes
                self._attach_to_indexes(index_combination, candidate, best, current_cost)
            if best['benefit_to_size_ratio'] <= 0 or (best['cost'] * self.min_cost_improvement) >= current_cost:
                break
            index_combination = best['combination']
            best['benefit_to_size_ratio'] = 0
            current_cost = best['cost']
            index_combination_size = sum(x.estimated_size
                                         for x in index_combination)

        return index_combination

    def _attach_to_indexes(self, index_combination, candidate, best, current_cost):
        assert candidate.is_single_column() == True, 'Attach to indexes called with multi column index'

        for position, index in enumerate(index_combination):
            if index.appendable_by(candidate):
                new_combination = index_combination.copy()
                new_combination[position] = Index(index.columns +
                    candidate.columns)
                if new_combination[position] in index_combination:
                    continue
                self._evaluate_combination(new_combination, best,
                    current_cost)

    def _remove_candidates_too_large_for_budget(self, index_combination_size, candidates):
        new_candidates = []
        for candidate in candidates:
            if candidate.estimated_size is None:
                new_candidates.append(candidate)
                continue
            combined_size = candidate.estimated_size + index_combination_size
            if combined_size <= self.budget:
                new_candidates.append(candidate)

        return new_candidates

    def _evaluate_combination(self, index_combination, best,
                              current_cost):
        cost = self._retrieve_cost(index_combination)
        benefit = current_cost - cost
        size = sum(x.estimated_size for x in index_combination)
        ratio = benefit / size
        if ratio > best['benefit_to_size_ratio'] and size <= self.budget:
            logging.debug(f'new best cost and size: {cost}\t'
                          f'{round(size/1000000, 2)}MB')
            best['combination'] = index_combination
            best['benefit_to_size_ratio'] = ratio
            best['cost'] = cost

    def _retrieve_cost(self, indexes):
        cost = self.cost_evaluation.calculate_cost(self.workload, indexes,
                                                   store_size=True)
        return cost

    # The cost to get to the new index combination, i.e. cost of
    # adding new indexes and dropping existing unneeded indexes
    def _retrieve_reconfig_cost(self, new, existing_indexes=None):
        if existing_indexes == None:
            existing_indexes = []
        return 0
